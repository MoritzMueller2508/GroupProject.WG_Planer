type WG {
  id: ID!
  name: String!
  address: String!
  city: String!
  plz: String!
  shoppingList: ShoppingList
  householdDevices: HouseholdDevices
  news: News
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type ShoppingList {
  id: ID!
  itemName: String!
  value: String
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type HouseholdDevices {
  id: ID!
  deviceName: String!
  value: String
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

type News {
  id: ID!
  title: String!
  text: String
  _version: Int!
  _deleted: Boolean
  _lastChangedAt: AWSTimestamp!
}

enum ModelSortDirection {
  ASC
  DESC
}

type ModelWGConnection {
  items: [WG]
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelStringInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIDInput {
  ne: ID
  eq: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
  size: ModelSizeInput
}

input ModelIntInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelFloatInput {
  ne: Float
  eq: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelBooleanInput {
  ne: Boolean
  eq: Boolean
  attributeExists: Boolean
  attributeType: ModelAttributeTypes
}

input ModelSizeInput {
  ne: Int
  eq: Int
  le: Int
  lt: Int
  ge: Int
  gt: Int
  between: [Int]
}

input ModelWGFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  address: ModelStringInput
  city: ModelStringInput
  plz: ModelStringInput
  and: [ModelWGFilterInput]
  or: [ModelWGFilterInput]
  not: ModelWGFilterInput
}

type Query {
  syncWGS(filter: ModelWGFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelWGConnection
  getWG(id: ID!): WG
  listWGs(filter: ModelWGFilterInput, limit: Int, nextToken: String): ModelWGConnection
  syncUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelUserConnection
  getUser(id: ID!): User
  listUsers(filter: ModelUserFilterInput, limit: Int, nextToken: String): ModelUserConnection
  syncShoppingLists(filter: ModelShoppingListFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelShoppingListConnection
  getShoppingList(id: ID!): ShoppingList
  listShoppingLists(filter: ModelShoppingListFilterInput, limit: Int, nextToken: String): ModelShoppingListConnection
  syncHouseholdDevices(filter: ModelHouseholdDevicesFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelHouseholdDevicesConnection
  getHouseholdDevices(id: ID!): HouseholdDevices
  listHouseholdDevicess(filter: ModelHouseholdDevicesFilterInput, limit: Int, nextToken: String): ModelHouseholdDevicesConnection
  syncNews(filter: ModelNewsFilterInput, limit: Int, nextToken: String, lastSync: AWSTimestamp): ModelNewsConnection
  getNews(id: ID!): News
  listNewss(filter: ModelNewsFilterInput, limit: Int, nextToken: String): ModelNewsConnection
}

input CreateWGInput {
  id: ID
  name: String!
  address: String!
  city: String!
  plz: String!
  _version: Int
  wGShoppingListId: ID
  wGHouseholdDevicesId: ID
  wGNewsId: ID
}

input UpdateWGInput {
  id: ID!
  name: String
  address: String
  city: String
  plz: String
  _version: Int
  wGShoppingListId: ID
  wGHouseholdDevicesId: ID
  wGNewsId: ID
}

input DeleteWGInput {
  id: ID
  _version: Int
}

type Mutation {
  createWG(input: CreateWGInput!, condition: ModelWGConditionInput): WG
  updateWG(input: UpdateWGInput!, condition: ModelWGConditionInput): WG
  deleteWG(input: DeleteWGInput!, condition: ModelWGConditionInput): WG
  createUser(input: CreateUserInput!, condition: ModelUserConditionInput): User
  updateUser(input: UpdateUserInput!, condition: ModelUserConditionInput): User
  deleteUser(input: DeleteUserInput!, condition: ModelUserConditionInput): User
  createShoppingList(input: CreateShoppingListInput!, condition: ModelShoppingListConditionInput): ShoppingList
  updateShoppingList(input: UpdateShoppingListInput!, condition: ModelShoppingListConditionInput): ShoppingList
  deleteShoppingList(input: DeleteShoppingListInput!, condition: ModelShoppingListConditionInput): ShoppingList
  createHouseholdDevices(input: CreateHouseholdDevicesInput!, condition: ModelHouseholdDevicesConditionInput): HouseholdDevices
  updateHouseholdDevices(input: UpdateHouseholdDevicesInput!, condition: ModelHouseholdDevicesConditionInput): HouseholdDevices
  deleteHouseholdDevices(input: DeleteHouseholdDevicesInput!, condition: ModelHouseholdDevicesConditionInput): HouseholdDevices
  createNews(input: CreateNewsInput!, condition: ModelNewsConditionInput): News
  updateNews(input: UpdateNewsInput!, condition: ModelNewsConditionInput): News
  deleteNews(input: DeleteNewsInput!, condition: ModelNewsConditionInput): News
}

input ModelWGConditionInput {
  name: ModelStringInput
  address: ModelStringInput
  city: ModelStringInput
  plz: ModelStringInput
  and: [ModelWGConditionInput]
  or: [ModelWGConditionInput]
  not: ModelWGConditionInput
}

enum ModelAttributeTypes {
  binary
  binarySet
  bool
  list
  map
  number
  numberSet
  string
  stringSet
  _null
}

type Subscription {
  onCreateWG: WG @aws_subscribe(mutations: ["createWG"])
  onUpdateWG: WG @aws_subscribe(mutations: ["updateWG"])
  onDeleteWG: WG @aws_subscribe(mutations: ["deleteWG"])
  onCreateUser: User @aws_subscribe(mutations: ["createUser"])
  onUpdateUser: User @aws_subscribe(mutations: ["updateUser"])
  onDeleteUser: User @aws_subscribe(mutations: ["deleteUser"])
  onCreateShoppingList: ShoppingList @aws_subscribe(mutations: ["createShoppingList"])
  onUpdateShoppingList: ShoppingList @aws_subscribe(mutations: ["updateShoppingList"])
  onDeleteShoppingList: ShoppingList @aws_subscribe(mutations: ["deleteShoppingList"])
  onCreateHouseholdDevices: HouseholdDevices @aws_subscribe(mutations: ["createHouseholdDevices"])
  onUpdateHouseholdDevices: HouseholdDevices @aws_subscribe(mutations: ["updateHouseholdDevices"])
  onDeleteHouseholdDevices: HouseholdDevices @aws_subscribe(mutations: ["deleteHouseholdDevices"])
  onCreateNews: News @aws_subscribe(mutations: ["createNews"])
  onUpdateNews: News @aws_subscribe(mutations: ["updateNews"])
  onDeleteNews: News @aws_subscribe(mutations: ["deleteNews"])
}

type ModelUserConnection {
  items: [User]
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelUserFilterInput {
  id: ModelIDInput
  name: ModelStringInput
  email: ModelStringInput
  password: ModelStringInput
  and: [ModelUserFilterInput]
  or: [ModelUserFilterInput]
  not: ModelUserFilterInput
}

input CreateUserInput {
  id: ID
  name: String!
  email: String!
  password: String!
  _version: Int
}

input UpdateUserInput {
  id: ID!
  name: String
  email: String
  password: String
  _version: Int
}

input DeleteUserInput {
  id: ID
  _version: Int
}

input ModelUserConditionInput {
  name: ModelStringInput
  email: ModelStringInput
  password: ModelStringInput
  and: [ModelUserConditionInput]
  or: [ModelUserConditionInput]
  not: ModelUserConditionInput
}

type ModelShoppingListConnection {
  items: [ShoppingList]
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelShoppingListFilterInput {
  id: ModelIDInput
  itemName: ModelStringInput
  value: ModelStringInput
  and: [ModelShoppingListFilterInput]
  or: [ModelShoppingListFilterInput]
  not: ModelShoppingListFilterInput
}

input CreateShoppingListInput {
  id: ID
  itemName: String!
  value: String
  _version: Int
}

input UpdateShoppingListInput {
  id: ID!
  itemName: String
  value: String
  _version: Int
}

input DeleteShoppingListInput {
  id: ID
  _version: Int
}

input ModelShoppingListConditionInput {
  itemName: ModelStringInput
  value: ModelStringInput
  and: [ModelShoppingListConditionInput]
  or: [ModelShoppingListConditionInput]
  not: ModelShoppingListConditionInput
}

type ModelHouseholdDevicesConnection {
  items: [HouseholdDevices]
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelHouseholdDevicesFilterInput {
  id: ModelIDInput
  deviceName: ModelStringInput
  value: ModelStringInput
  and: [ModelHouseholdDevicesFilterInput]
  or: [ModelHouseholdDevicesFilterInput]
  not: ModelHouseholdDevicesFilterInput
}

input CreateHouseholdDevicesInput {
  id: ID
  deviceName: String!
  value: String
  _version: Int
}

input UpdateHouseholdDevicesInput {
  id: ID!
  deviceName: String
  value: String
  _version: Int
}

input DeleteHouseholdDevicesInput {
  id: ID
  _version: Int
}

input ModelHouseholdDevicesConditionInput {
  deviceName: ModelStringInput
  value: ModelStringInput
  and: [ModelHouseholdDevicesConditionInput]
  or: [ModelHouseholdDevicesConditionInput]
  not: ModelHouseholdDevicesConditionInput
}

type ModelNewsConnection {
  items: [News]
  nextToken: String
  startedAt: AWSTimestamp
}

input ModelNewsFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  text: ModelStringInput
  and: [ModelNewsFilterInput]
  or: [ModelNewsFilterInput]
  not: ModelNewsFilterInput
}

input CreateNewsInput {
  id: ID
  title: String!
  text: String
  _version: Int
}

input UpdateNewsInput {
  id: ID!
  title: String
  text: String
  _version: Int
}

input DeleteNewsInput {
  id: ID
  _version: Int
}

input ModelNewsConditionInput {
  title: ModelStringInput
  text: ModelStringInput
  and: [ModelNewsConditionInput]
  or: [ModelNewsConditionInput]
  not: ModelNewsConditionInput
}
